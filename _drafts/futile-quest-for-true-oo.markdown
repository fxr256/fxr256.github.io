---
layout: post
title:  "The Futile Quest for True Object Orientation"
date:   2019-06-29 17:58:01 +0100
categories: software design
---
Object-oriented software is ubiquitious today. The idea of object-oriented software originated in the 1960s and rose to dominance in the 1990s. Today, most main-stream languages are at least somewhat object-oriented. Despite this obvious success, the paradigm is still somewhat nebulous. What does it really mean to write object-oriented code? What needs to be done to finally make software engineering reach the next level, where we can write bug-free, maintanable code on time and on budget? A multi-paradigm language like Java claims to be object-oriented, but a lot of Java code out in the wild looks quite procedural. Is there any meaningful difference between a Java Bean and a simple data structer like a C struct (except that the Java bean requires more lines of code)? There was a lot of hype around object-orientation in the 90s and clearly the paradigm hasn't lived up to the hype: Today's code is still mostly not reusable and strong modularisation isn't widespread either. And here is where the quest for true object-orientation comes in.

Some software experts believe that the promised benefits of object-oriented software can be achieved if only the code is structured correctly. One prominent believer in true OO is [Dave West](http://davewest.us/). In his book [Object Thinking](http://davewest.us/product/object-thinking/) he lays out the correct mindset need to build truly object-oriented software. The book is highly philosophical at times and while interesting not really usable in practice. In fact, he mentions later in the book that no currently available programming language is truly object-oriented from his point of view. While he mentions having used true OO in his work as a software consultant, he never shares any real code. This is quite disappointing as it would really help flesh out his ideas. One core idea in the more concrete parts of the book is that of a self-evaluating business rule at the heart of the software. This rule is supposed to represent a procedure in the buisness domain (e.g. calculating somebody's salary) and should have the ability to evaluate itself, i. e. execute itself. In West's approach the business rules are the core of the software with only small layers for presentation and data storage around them. While this seems like a sound idea, West sadly never gives a code example for such a business rule. All in all, he stays frustratingly vague in his book.